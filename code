import json
import csv
import random
from datetime import datetime, timedelta
import os

# Output directory
output_dir = r"C:/Users/sai62.TRN/Downloads"
json_path = os.path.join(output_dir, "enhanced_ecommerce_exception_logs.json")
csv_path = os.path.join(output_dir, "enhanced_ecommerce_exception_logs.csv")

# --- Your original exception template (partial for example) ---
exceptions_template = {
    'User Registration & Authentication': {
        'UserValidator': {
            'validateCredentials': [
                'UsernameExistsError', 'EmailExistsError', 'InvalidEmailFormatError',
                'PasswordComplexityFailureError', 'AccountNotVerifiedError'
            ],
            'validateLogin': [
                'InvalidLoginCredentialsError', 'AccountLockedError', 'SessionExpirationError'
            ]
        }
    }
}

exception_descriptions = {
    'UsernameExistsError': 'The provided username is already taken by another user.',
    'EmailExistsError': 'An account with this email address already exists.',
    'InvalidEmailFormatError': 'The email address format is invalid.',
    'PasswordComplexityFailureError': 'Password does not meet complexity requirements.',
    'AccountNotVerifiedError': 'The account has not been verified yet.',
    'InvalidLoginCredentialsError': 'The provided login credentials are incorrect.',
    'AccountLockedError': 'The account has been locked due to multiple failed login attempts.',
    'SessionExpirationError': 'The user session has expired.'
}

# --- Additional exceptions ---
additional_exceptions = {
    'User Registration & Authentication': {
        'UserValidator': {
            'registerUser': ['CaptchaVerificationFailedError'],
            'validateLogin': ['TooManyLoginAttemptsError']
        }
    }
}

# Merge new exceptions into existing template
def merge_exceptions(base, additions):
    for app, services in additions.items():
        if app not in base:
            base[app] = {}
        for service, methods in services.items():
            if service not in base[app]:
                base[app][service] = {}
            for method, exc_list in methods.items():
                if method in base[app][service]:
                    base[app][service][method].extend(exc_list)
                else:
                    base[app][service][method] = exc_list

merge_exceptions(exceptions_template, additional_exceptions)

# --- User List ---
users = [f"user{str(i).zfill(3)}" for i in range(1, 201)]

# --- Log Generator ---
def generate_logs(num_records=5000):
    logs = []
    for _ in range(num_records):
        app = random.choice(list(exceptions_template.keys()))
        service = random.choice(list(exceptions_template[app].keys()))
        methods = exceptions_template[app][service]

        if isinstance(methods, dict):
            method = random.choice(list(methods.keys()))
            exceptions = methods[method]
        else:
            method = random.choice(methods)
            exceptions = [method]

        exc = random.choice(exceptions)
        description = exception_descriptions.get(exc, f"Autogenerated description for {exc}.")
        fake_time = datetime.now() - timedelta(minutes=random.randint(0, 100000))
        logs.append({
            'user': random.choice(users),
            'application_component': app,
            'service': service,
            'method_name': method,
            'exception': exc,
            'description': description,
            'date_time': fake_time.strftime('%Y-%m-%d %H:%M:%S')
        })
    return logs

# --- Generate and Save ---
logs = generate_logs()

# Save JSON
with open(json_path, "w") as f:
    json.dump(logs, f, indent=4)

# Save CSV
with open(csv_path, "w", newline='') as csvfile:
    writer = csv.DictWriter(csvfile, fieldnames=logs[0].keys())
    writer.writeheader()
    writer.writerows(logs)

print(f"âœ… JSON and CSV files saved to {output_dir}")
